## send 返回并不意味着数据就发送成功
```
sokcet 缓冲区
1.用户发送消息写给send buffer 
2.用户接收消息写个recv buffer


netstat -nt
Proto 协议
Recv-Q  接收缓冲区
Send-Q 发送缓冲去
Local Address 本地地址 
Foreign Address  远端地址
State 

send 数据只是拷贝到send-Q 什么时候发送这是OS 说了算

send 数据 OS 判断send-Q 数据满了会怎么办
1.如果soket 设置的是阻塞 send-Q 满了 会在那里死等呆呆数据拷贝到send-Q 缓冲去
2.非阻塞 发送 程序会返回  EAGAIN  让你别等了待会在去尝试发送  



缓冲去未空 recv 会怎样
1.socket 阻塞 会一致等待缓冲区有数据 并且将数据拷贝到用户缓冲区

2.socket 非阻塞 程序立即返回 EAGAIN



缓冲区有数据执行了close 会怎样
1.缓冲区有数据未读 清除缓冲区向对端发送RST
2.缓冲区未空 调用 tcp_send_fin 开始四次挥手

如果发送缓冲区有数据时，执行close了，会怎么样？
1.内核会把发送缓冲区最后一个数据块拿出来。然后置为 FIN。
socket 缓冲区是个先进先出的队列，这种情况是指内核会等待TCP层安静把发送缓冲区数据都发完，最后再执行 四次挥手的第一次挥手（FIN包）。


UDP也有缓冲区吗
有没有缓冲区和协议是否是TCP or UDP 关系不大 只要使用sokcet 就会存在一个发送缓冲去和接收缓冲区

```