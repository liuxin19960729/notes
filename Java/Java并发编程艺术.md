# Java并发编程艺术
## 2
```
volatile
    1.写数据保证这个数据只能由一个cpu写入内存
    2.如果某一cpu将数据写入内存,这一操作会被其他cpu嗅探,如果其他cpu存在共享区域则会使该区域设置为无效,下一回使用的时候会直接到内存将缓冲从新填充使用



synchronized
    代码块同步实现通过 monitorenter monitorexit 
    monitorenter 编译时插入同步代码块前
    monitorexit  编译时放入异常和结束的地方


    锁的四种状态 无锁 偏向锁 轻量锁 重量级锁
    note:锁可以升级但是不能降级

    1.偏向锁:
    测试Object头是否是指向该线程偏向锁
        成功 线程已经获得锁
        失败
            测试当前的锁是否是偏向锁
               不是
                    CAS 竞争锁
               是
                    使用CAS将Object头设置为当前线程id(指向该线程)


    偏向锁撤销
      1.请求撤销
        B尝试获取A线程偏向锁,JVM发现Owner不是自己,发起撤销请求
      2.进入安全点
        等待安全点所有Java线程都会被JVM 暂停
        并且线程A的栈帧是稳定的
      3.检查偏向锁持有者的状态
         3.1线程A已经挂了将对象头修改为无锁
           线程B可以重新去获取偏向锁或者轻量锁
         
```