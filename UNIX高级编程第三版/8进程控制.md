# 8进程控制
## 8.1 引言
## 8.2 进程标识
```c
进程ID 唯一 可复用(当一个进程终止进程ID乘务复用的候选者)
note:大多数UNIX使用延迟复用的算法

系统中存在一些专用的进程

ID 0 调度进程(系统进程)

ID 1 init 进程  /sbin/init -> /lib/systemd/systemd (普通用户进程 以超级特权运行)
            1.读取系统有关的初始化文件
                /etc/rc*
                /etc/init.d/
                ....
            2.将系统引导到一个多用户的状态


// 获取进程ID
pid getpid(void)
// 获取进程的父进程ID
pid getppid(void)

// 获取进程的实际用户id 启动程序的用户
uid_t getuid(void)
// 获取进程的有效用户id 系统判断你是否有权限
uid_t geteuid(void)
    -rwsr-xr-x 1 root root 54256 可执行文件存在 s 位 (setuid)
    geteuid 就是0

gid_t getgid(void)
gid_t getegid(void)
```
## 8.3 函数fork
```
fork()
子进程是父进程的副本(堆,栈.....)
由于大部分场景fork 之后 执行exec 并没有使用父进程代码 和 数据 等 内存副本 所有现代OS 系统使用写时拷贝技术(Copy on Write)


fork 和 IO 函数的交互关系
note:系统write 是没有缓存区的 
然而标准的写入时缓冲区 交换环境下 flush 是 以 行未单位刷入的输出
重定向写入到磁盘就不是强制刷新 fork 之后 子进程 和 父 进程 两个个有一份相关的缓冲数据



fork 之后 子进程会继承父进程一些属性
1.打开的文件
2.uid gid euid egid
3.附属组
4.进程组ID
......

那些数据不会被继承
1.子进程不继承父进程的文件锁
2.子进程将未处理的闹钟清理
3.子进程将父进程的未处理的信号集设置问空集
.......

fork 有两种用法
1.父进程复制自己,使子进程和父进程执行同等代码
    这种方式在网络服务器中常见
    父进程等待服务请求,服务请求到达fork() 子进程处理请求
    父进程继续等待请求
2.进程执行不同程序  fork 之后 exec 执行代码
```
## 函数vfork
```
vfork 创建一个新进程,新进程的母的exec 一个新程序

```